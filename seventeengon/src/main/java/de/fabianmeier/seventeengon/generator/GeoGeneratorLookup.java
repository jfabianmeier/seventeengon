package de.fabianmeier.seventeengon.generator;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.FileUtils;

import de.fabianmeier.seventeengon.geoobjects.GeoHolder;
import de.fabianmeier.seventeengon.naming.CompName;
import de.fabianmeier.seventeengon.naming.CompNamePattern;
import de.fabianmeier.seventeengon.naming.Sentence;
import de.fabianmeier.seventeengon.naming.SentencePattern;

/**
 * The lookup for the generator objects.
 * 
 * @author jfabi
 *
 */
public class GeoGeneratorLookup
{
	private static Map<SentencePattern, GeoGenerator> lookUp = new HashMap<>();
	private static Map<CompNamePattern, GeoGenerator> compLookUp = new HashMap<>();

	private static Map<ReducedSentencePattern, SentencePattern> secondLookUp = new HashMap<>();

	private static File geoDefinition = new File("C:\\temp\\geoDefinition.txt");

	static
	{
		add(AngleGenerator.ANGLE, new AngleGenerator());
		add(AngleGenerator.BAC, new AngleGenerator());
		add(CircleGenerator.CIRCLE, new CircleGenerator());

		add(PointGenerator.INX, new PointGenerator());
		add(PointGenerator.CUT, new PointGenerator());
		add(PointGenerator.ONX, new PointGenerator());
		add(PointGenerator.OUTSIDE, new PointGenerator());
		add(PointGenerator.OVER, new PointGenerator());
		add(PointGenerator.OVERINSIDE, new PointGenerator());
		add(PointGenerator.SIMPLE, new PointGenerator());
		add(SegmentGenerator.SEGMENT, new SegmentGenerator());
		add(SegmentGenerator.AB, new SegmentGenerator());
		add(TriangleGenerator.TRIANGLE, new TriangleGenerator());
		add(TriangleGenerator.ABC, new TriangleGenerator());
		add(EqualityGenerator.ASSIGN, new EqualityGenerator());
		add(LineGenerator.LINE, new LineGenerator());

		add(LineGenerator.AB, new LineGenerator());

		try
		{
			List<String> geoLines = FileUtils.readLines(geoDefinition, Charset.defaultCharset());

			boolean lineStart = true;

			Sentence toDefine = null;
			List<Sentence> blockLines = new ArrayList<Sentence>();

			for (String line : geoLines)
			{
				if (line.trim().equals(""))
				{
					lineStart = true;
					if (toDefine != null)
					{
						add(toDefine, blockLines);
					}
					continue;
				}

				String trimmedLine = line.trim();

				if (!Sentence.isSentence(trimmedLine))
				{
					throw new IOException("No valid sentence: " + trimmedLine);
				}

				Sentence lineSentence = new Sentence(trimmedLine);

				if (lineStart)
				{
					toDefine = lineSentence;
					blockLines = new ArrayList<Sentence>();
					lineStart = false;
					continue;
				}

				blockLines.add(lineSentence);
			}

		} catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * 
	 * @param input
	 *            An input sentence
	 * @return A replacement if the sentence pattern is not contained in the
	 *         data base
	 * @throws IOException
	 *             if no replacement pattern is found
	 */
	private static SentencePattern getValidSentencePattern(Sentence input) throws IOException
	{
		SentencePattern pattern = new SentencePattern(input);

		if (lookUp.containsKey(pattern))
		{
			return pattern;
		}

		ReducedSentencePattern reducedPattern = new ReducedSentencePattern(pattern);
		SentencePattern pattern2 = secondLookUp.get(reducedPattern);

		if (pattern2 != null)
		{
			System.out.println("Replace pattern " + pattern.toString() + " by " + pattern2.toString());
			return pattern2;
		}

		for (ReducedSentencePattern rsp : secondLookUp.keySet())
		{
			if (rsp.compatibleWith(reducedPattern))
			{
				SentencePattern pattern3 = secondLookUp.get(rsp);
				System.out.println("Replace pattern " + pattern.toString() + " by " + pattern3.toString()
						+ " due to compatability.");
				return pattern3;
			}
		}

		throw new IOException("No compatible pattern found for " + pattern + ".");

	}

	/**
	 * Adds the objects generated by the sentence to geoHolder.
	 * 
	 * @param geoHolder
	 *            geoHolder
	 * @param input
	 *            Sentence
	 * @return if the drawing was successful
	 * @throws IOException
	 *             if some sentence is not well-formed or not recorded.
	 */
	public static boolean generateAndAdd(GeoHolder geoHolder, Sentence input) throws IOException
	{
		SentencePattern pattern = getValidSentencePattern(input);
		GeoGenerator generator = get(pattern);
		return generator.generateAndAdd(geoHolder, generateNewSentenceForPattern(pattern, input));
	}

	/**
	 * 
	 * @param pattern
	 *            a pattern
	 * @param input
	 *            an input sentence
	 * @return a sentence of the pattern with the composite names of the input
	 */
	private static Sentence generateNewSentenceForPattern(SentencePattern pattern, Sentence input)
	{
		List<CompName> compNameList = input.getCompositeNames();
		StringBuilder back = new StringBuilder();

		List<String> wordList = pattern.getWords();

		int compCount = 0;
		for (String word : wordList)
		{
			if (word != null)
			{
				back.append(word + " ");
			} else
			{
				back.append(compNameList.get(compCount) + " ");
				compCount++;
				if (compCount > compNameList.size())
				{
					throw new IllegalArgumentException("Not fitting pattern and input: " + pattern + " vs. " + input);
				}
			}

		}

		return new Sentence(back.toString());

	}

	/**
	 * 
	 * @param pattern
	 *            a pattern
	 * @return the GeoGenerator for the pattern
	 * @throws IOException
	 *             if none exists
	 */
	public static GeoGenerator get(SentencePattern pattern) throws IOException
	{
		return lookUp.get(pattern);

	}

	/**
	 * 
	 * @param sentence
	 *            a sentence
	 * @return the GeoGenerator for the pattern of the sentence
	 * @throws IOException
	 *             if no GeoGenerator for the pattern exists
	 */
	public static GeoGenerator get(Sentence sentence) throws IOException
	{
		return get(new SentencePattern(sentence));
	}

	/**
	 * 
	 * @param compPattern
	 *            a CompPattern from the dictionary
	 * @return the saved geoGenerator, otherwise an exception
	 * @throws IOException
	 *             If the compPattern is not contained in the Lookup
	 */
	public static GeoGenerator get(CompNamePattern compPattern) throws IOException
	{
		if (!compLookUp.containsKey(compPattern))
		{
			throw new IOException("SentencePattern " + compPattern + " not defined.");
		}

		return compLookUp.get(compPattern);
	}

	/**
	 * adds a sentence/geoGenerator pair to the dictionary.
	 * 
	 * @param sentencePattern
	 *            SentencePattern
	 * @param geoGen
	 *            GeoGenerator
	 */
	public static void add(SentencePattern sentencePattern, GeoGenerator geoGen)
	{
		lookUp.put(sentencePattern, geoGen);
		secondLookUp.put(new ReducedSentencePattern(sentencePattern), sentencePattern);
	}

	/**
	 * A sentence with a list of sentences which define it.
	 * 
	 * @param sentence
	 *            Sentence
	 * @param replacement
	 *            Replacement list
	 */
	public static void add(Sentence sentence, List<Sentence> replacement)
	{
		GeoGenerator localGeo = new RecursiveGeoGenerator(sentence, replacement);

		add(new SentencePattern(sentence), localGeo);

	}

	/**
	 * adds the generator to the pattern.
	 * 
	 * @param compNamePattern
	 *            a pattern
	 * @param geoGen
	 *            a GeoGenerator
	 */
	public static void add(CompNamePattern compNamePattern, GeoGenerator geoGen)
	{
		compLookUp.put(compNamePattern, geoGen);
	}

}
